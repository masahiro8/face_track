{"version":3,"sources":["components/VideoCanvas.scss","canvas.point.js","components/FaceDetect.jsx","config.js","components/VideoCanvas.jsx","util/vector.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","overlayCanvas","videoimage","setPoint","canvas","pos","col","ctx","getContext","fillStyle","fillRect","x","y","FaceDetect","_Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","pointlog","net","faceapi","state","faceDetect","inherits","createClass","key","value","_componentDidMount","asyncToGenerator","regenerator_default","a","mark","_callee2","_this2","wrap","_context2","prev","next","tinyFaceDetector","load","console","log","setInterval","_callee","_context","predict","stop","interval","apply","arguments","_predict","_callee3","options","result","_context3","abrupt","inputSize","scoreThreshold","video","withFaceLandmarks","sent","setState","react_default","createElement","Component","VIDEO_SIZE","width","height","INTERVAL","Math","floor","Video","media","selfRef","initCam","navigator","mediaDevices","getUserMedia","audio","facingMode","size","p","Promise","resolve","then","stream","srcObject","onloadedmetadata","e","catch","err","alert","_this3","ref","setSelf","className","autoPlay","playsInline","Canvas","_this4","_this5","draw","getBoundingClientRect","context","drawImage","_this6","set","id","VideoImage","_Component3","_this7","_this8","styles","VideoCanvas_Video","setVideo","VideoCanvas_Canvas","setCanvas","shiftBase","b","toFixed","vectorLength","v","sqrt","dotProduct","distance","p1","p2","pow","src_App","App","overlay","landmarks","positions","initCanvas","VideoCanvas_VideoImage","FaceDetect_FaceDetect","_faceapi$getMediaDime","resizedResults","map","res","forSize","jawOutline","getJawOutline","nose","getNose","mouth","getMouth","leftEye","getLeftEye","rightEye","getRightEye","leftEyeBrow","getLeftEyeBrow","rightEyeBrow","getRightEyeBrow","getLandmarks","faceLandmarks","App_FaceDetectView","setRef","setOverlay","FaceDetectView","points","nextProps","drawPoints","drawParts","length","_","point","index","initPointRate","myPoint","begin","end","_begin","_end","vector","_end_vec","vec_length","point_distance","rate","dot","vec","distanceFromCenter","cross","radian","bool","PI","vec2","cos","sin","_myPoint","_crossProduct","distanceFromEdge","abs","_dotProduct","cos_theta","_a","_b","dotDistance","math","acos","rate_vec_point","rate_from_edge","_points","clearRect","step","parts","concat","getColor","rect","clientX","left","clientY","top","push","onClick","addPoint","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a72c1512.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"overlayCanvas\":\"_1VTjcrIdjUewwZ-qVkXQxP\",\"videoimage\":\"_27P8rrrUDhjUTuQVCNHvHs\"};","import * as faceapi from \"face-api.js/dist/face-api.js\";\r\n\r\nexport const setPoint = ( canvas , pos  , col) =>{\r\n  const ctx = canvas.getContext(\"2d\");\r\n  ctx.fillStyle = col||\"#0ff\";\r\n  ctx.fillRect(pos.x,pos.y,4,4);\r\n}\r\n\r\nexport const getLandmarks = (landmarks) => {\r\n  const jawOutline = landmarks.getJawOutline();\r\n  const nose = landmarks.getNose();\r\n  const mouth = landmarks.getMouth();\r\n  const leftEye = landmarks.getLeftEye();\r\n  const rightEye = landmarks.getRightEye();\r\n  const leftEyeBrow = landmarks.getLeftEyeBrow();\r\n  const rightEyeBrow = landmarks.getRightEyeBrow();\r\n  return {\r\n    nose:nose,\r\n    mouth:mouth,\r\n    leftEye:leftEye,\r\n    rightEye:rightEye,\r\n    leftEyeBrow:leftEyeBrow,\r\n    rightEyeBrow:rightEyeBrow,\r\n    jawOutline:jawOutline,\r\n  }\r\n}\r\n\r\nexport const resizeCanvasAndResults = (dimensions, canvas, results) => {\r\n  const { width, height } = dimensions instanceof HTMLVideoElement\r\n    ? faceapi.getMediaDimensions(dimensions)\r\n    : dimensions\r\n  canvas.width = width\r\n  canvas.height = height\r\n\r\n  // resize detections (and landmarks) in case displayed image is smaller than\r\n  // original size\r\n  return results.map(res => res.forSize(width, height))\r\n}\r\n\r\nexport const drawDetections = (dimensions, canvas, detections)=> {\r\n  console.log(\"drawDetections\" ,detections);\r\n  const resizedDetections = resizeCanvasAndResults(dimensions, canvas, detections)\r\n  faceapi.drawDetection(canvas, resizedDetections)\r\n}\r\n\r\nexport const drawLandmarks = (dimensions, canvas, results, withBoxes = true) => {\r\n  \r\n  const resizedResults = resizeCanvasAndResults(dimensions, canvas, results)\r\n  console.log(\"drawLandmarks = \",resizedResults);\r\n  if (withBoxes) {\r\n    faceapi.drawDetection(canvas, resizedResults.map(det => det.detection))\r\n  }\r\n\r\n  const faceLandmarks = resizedResults.map(det => det.landmarks)\r\n  const drawLandmarksOptions = {\r\n    lineWidth: 2,\r\n    drawLines: true,\r\n    color: 'green'\r\n  }\r\n  faceapi.drawLandmarks(canvas, faceLandmarks, drawLandmarksOptions)\r\n}","import React, { Component } from \"react\";\nimport * as _ from \"lodash\";\nimport * as faceapi from \"face-api.js/dist/face-api.js\";\nimport { constant } from \"@tensorflow/tfjs-layers/dist/exports_initializers\";\nimport {setPoint,getLandmarks } from '../canvas.point';\n\n// tiny_face_detector options\nlet inputSize = 128\nlet scoreThreshold = 0.5\n\nexport class FaceDetect extends Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n    this.pointlog = null;\n    this.net = new faceapi.FaceLandmark68TinyNet();\n    this.state = {\n      faceDetect: {},\n    };\n  }\n\n  async componentDidMount() {\n\n    //必要なモデルのロード\n    await faceapi.nets.tinyFaceDetector.load('models/face/');\n    await faceapi.loadFaceLandmarkModel('models/face/');\n    console.log(\"load models\");\n    setInterval(async () => {\n      await this.predict();\n    }, this.props.interval);\n  }\n\n  async predict() {\n    if (!this.props.canvas) return;\n    //検出\n    let inputSize = 128;\n    let scoreThreshold = 0.5;\n    const options = new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold })\n    const result = await faceapi.detectSingleFace(this.props.video, options).withFaceLandmarks();\n    //console.log(\"predict result\" ,result);\n    if (result) {\n      //console.log(\"result \" , result );\n      // const { width, height } = faceapi.getMediaDimensions(this.props.video);\n      // const resizedResults = [result].map(res => res.forSize(width, height));\n      this.setState({ faceDetect: result });\n      this.props.result(result);\n    }\n  }\n\n  render() {\n    return (\n      <div/>\n    );\n  }\n}","export const location = 'https://192.168.100.109:3000/';\n\nexport const VIDEO_SIZE = {\n  width:640,\n  height:480,\n}\nexport const INTERVAL =  Math.floor(1000/30);\n\n//追従するパーツ\nexport const PARTS_INDEX = [30,38,44]; // 鼻 左目　右目","import React, { Component } from \"react\";\nimport styles from './VideoCanvas.scss';\nimport {VIDEO_SIZE} from '../config';\n\nclass Video extends Component {\n  constructor(props) {\n    super(props);\n    this.media = null;\n    this.selfRef = null;\n  }\n\n  async componentDidMount() {\n    await this.initCam();\n    console.log(\"detect init\");\n  }\n\n  async initCam() {\n\n    // const stream = await navigator.mediaDevices.getUserMedia({ video: {} }) \n    this.media = navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: \"environment\",\n        width: this.props.size.width, \n        // height: this.props.size.height,\n      },\n    });\n\n    let p = new Promise( resolve =>{\n      this.media.then(stream => {\n        this.selfRef.srcObject = stream;\n        this.selfRef.onloadedmetadata = function(e) {\n          console.log(\"Onload video\" , e);\n          resolve();\n        };\n      });\n      \n      this.media.catch(err => {\n        alert(err);\n      });\n    });\n\n    return p;\n    \n  }\n\n  render() {\n    return (\n      <video\n        ref={ref => {\n          this.selfRef = ref;\n          this.props.setSelf(ref);\n        }}\n        className=\"video\"\n        autoPlay\n        playsInline\n        width={VIDEO_SIZE.width}\n        height={VIDEO_SIZE.height}\n      />\n    );\n  }\n}\n\nclass Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n  }\n\n  componentDidMount() {\n    setInterval(() => {\n      this.draw();\n    }, this.props.interval);\n  }\n\n  draw() {\n    if (!this.props.video || !this.props.canvas) {\n      return;\n    }\n    let rect = this.props.video.getBoundingClientRect();\n    var context = this.canvas.getContext(\"2d\");\n    this.canvas.width = this.props.size.width;\n    this.canvas.height = this.props.size.height;\n    context.drawImage(\n      this.props.video,0, 0,\n      this.props.size.width,\n      this.props.size.height);\n  }\n\n  render() {\n    return (\n      <canvas\n        ref={ref => {\n          this.canvas = ref;\n          this.props.set(ref);\n        }}\n        id={\"canvas\"}\n        className=\"canvas\"\n      />\n    );\n  }\n}\n\nexport class VideoImage extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      video: null,\n      canvas: null,\n    };\n  }\n\n  setVideo(ref) {\n    if (this.state.video !== ref && ref) {\n      this.setState({ video: ref });\n      this.props.video(ref);\n    }\n  }\n\n  setCanvas(ref) {\n    if (this.state.canvas !== ref && ref) {\n      this.setState({ canvas: ref });\n      this.props.canvas(ref);\n    }\n  }\n\n  render(){\n    return(\n      <div className={styles[\"videoimage\"]}>\n        <Video\n          size = {this.props.size}\n          setSelf={ref => {\n            this.setVideo(ref);\n          }}\n        />\n        <Canvas\n          size = {this.props.size}\n          video={this.state.video}\n          set={ref => {\n            this.setCanvas(ref);\n          }}\n          interval={this.props.interval}\n        />\n      </div>\n    )\n  }\n}","    //原点補正\n    export const shiftBase = ( b ,p ) =>{\n      return {x:(p.x-b.x).toFixed(2),y:(p.y-b.y).toFixed(2)};\n    }\n    //ベクトル長さ\n    export const vectorLength =(v)=>{\n      return Math.sqrt( v.x * v.x + v.y * v.y);\n      //return Math.pow( ( v.x * v.x ) + ( v.y * v.y ), 0.5 );\n    }\n    //内積:正しい\n    export const dotProduct = (a,b) =>{\n      return a.x * b.x + a.y * b.y;\n    }\n\n    //外積\n    export const crossProduct = ( p , v ) =>{\n      return p.x * v.y - v.x * p.y;\n    }\n\n    //ベクトルのなす角(ラジアン)\n    //http://www.sousakuba.com/Programming/gs_two_vector_angle.html\n    //https://qiita.com/vkgtaro/items/b2cd00f376c427cb9ea6\n    export const theta = ( a, b ) => {\n      const _a = vectorLength(a);\n      const _b = vectorLength(b);\n      return Math.cos(dotProduct(a,b) / ( _a * _b ));\n    }\n\n    //ベクトル座標 座標,ベクトル\n    export const vecPos = (p,v) => {\n      return {x:p.x/v,y:p.y*v};\n    }\n    //２点間の距離:正しい\n    export const distance = (p1, p2) => {\n      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    };","import React, { Component } from \"react\";\nimport * as faceapi from \"face-api.js/dist/face-api.js\";\nimport * as _ from 'lodash';\nimport math from 'mathjs';\nimport {FaceDetect} from './components/FaceDetect';\nimport {VideoImage} from './components/VideoCanvas';\nimport {setPoint,getLandmarks } from './canvas.point';\nimport styles from './components/VideoCanvas.scss';\nimport { VIDEO_SIZE , INTERVAL } from './config';\nimport * as vector from './util/vector';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      video:null,\n      canvas: null,\n      overlay: null,\n      result : null,\n      landmarks : null,\n      positions : null,\n    };\n    this.overlay = null;\n  }\n\n  setCanvas(ref) {\n    if (this.state.canvas !== ref && ref) {\n      this.setState({ canvas: ref });\n    }\n  }\n\n  setVideo(ref) {\n    if (this.state.video !== ref && ref) {\n      this.setState({ video: ref });\n      console.log(\"setVideo \" );\n    }\n  }\n\n  setOverlay(ref) {\n    if (this.state.overlay !== ref && ref) {\n      this.setState({ overlay: ref });\n      this.initCanvas();\n      console.log(\"setOverlay \" );\n    }\n  }\n\n  initCanvas(){\n    if( !this.state.canvas || !this.state.overlay ) return;\n    this.setState({\n      width:VIDEO_SIZE.width,\n      height:VIDEO_SIZE.height\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <VideoImage \n          size = {VIDEO_SIZE}\n          interval={INTERVAL}\n          video ={(ref)=>{ this.setVideo(ref); }}\n          canvas = {(ref)=>{ this.setCanvas(ref); }}\n        />\n        <FaceDetect \n          canvas={this.state.canvas} \n          video={this.state.video}\n          interval={INTERVAL}\n          result={(result)=>{\n            const { width, height } = faceapi.getMediaDimensions(this.state.video);\n            const resizedResults = [result].map(res => res.forSize(width, height));\n            const landmarks = getLandmarks(resizedResults[0].faceLandmarks);\n\n            this.setState({\n              landmarks:landmarks,\n              positions:resizedResults[0].landmarks.positions\n            });\n          }} />\n        <FaceDetectView\n          video = {this.state.video}\n          landmarks ={this.state.landmarks}\n          positions = { this.state.positions}\n          setRef = {(ref)=>{this.setOverlay(ref)}}\n        />\n      </div>\n    );\n  }\n}\nexport default App;\n\nclass FaceDetectView extends Component {\n  constructor(props){\n    super(props);\n    this.canvas = null;\n\n    this.state ={\n      points:[]\n    };\n  }\n\n  componentWillReceiveProps(nextProps){\n    if(nextProps.landmarks) {\n      this.drawPoints();\n      this.drawParts();\n      if(this.state.points.length) {\n        _.each ( this.state.points ,  ( point , index ) =>{\n          this.initPointRate( point,index ,nextProps.positions[38] , nextProps.positions[44]);\n          this.setPoint(point,index ,nextProps.positions[38] , nextProps.positions[44]);\n        })\n      }\n    }\n  }\n\n  setCanvas ( ref ) {\n    this.canvas = ref;\n    this.props.setRef(ref);\n  }\n\n  setPoint ( myPoint, index , begin, end ) {\n    //原点をbeginとして補正\n    const _begin = { x:0 , y: 0};\n    const _end = vector.shiftBase( begin , end);\n    //ベクトル距離\n    const _end_vec = vector.vectorLength(_end);\n    //begin > end 距離\n    const vec_length = vector.distance(_begin , _end);\n    //線上の距離\n    const point_distance = vec_length*myPoint.rate.dot;\n    const vec = {\n      x : ( _begin.x+_end.x/_end_vec*point_distance ) + begin.x,\n      y : ( _begin.y+_end.y/_end_vec*point_distance ) + begin.y\n    }\n    //半径\n    const distanceFromCenter = vec_length*myPoint.rate.cross;\n    const r = myPoint.bool.cross?270:90;\n    const radian = r*Math.PI/180;\n    const vec2 = {\n      x:distanceFromCenter * Math.cos(radian) + vec.x,\n      y:distanceFromCenter * Math.sin(radian) + vec.y,\n    }\n    setPoint( this.canvas , {x:vec2.x , y:vec2.y} , `rgba(255,255,255)`);\n  }\n\n  initPointRate( myPoint, index , begin, end ) {\n\n    if ( myPoint.rate ) return;\n\n    //原点をbeginとして補正\n    const _begin = { x:0 , y: 0};\n    const _end = vector.shiftBase( begin , end);\n    const _myPoint = vector.shiftBase( begin ,myPoint.vector);\n    \n    //外積\n    const _crossProduct = vector.crossProduct(_end,_myPoint);\n    const distanceFromEdge = Math.abs(_crossProduct/vector.distance(_begin , _end));//頂点から|begin|endへの距離\n\n    //内積\n    const _dotProduct = vector.dotProduct(_end,_myPoint);// _dotProduct<0 -> 正\n    const cos_theta = vector.theta(_end,_myPoint);\n    const _theta = math.acos(cos_theta);//θ\n    const dotDistance = _theta*vector.vectorLength(_myPoint);//内積 -> 絶対値なので正負の判定を入れる必要がある\n\n    //割合\n    const vec_length = vector.distance(_begin , _end);\n    const rate_vec_point = dotDistance/vec_length;//正しい\n    const rate_from_edge = distanceFromEdge/vec_length;\n    \n    // console.log(\"cos_theta \",\n    //   vector.vectorLength(_end),\n    //   vector.vectorLength(_myPoint) , \n    //   cos_theta ,\n    //   _theta*180.0/Math.PI,\n    //   vector.dotProduct(_end,_myPoint),\n    // );\n\n    //初期値を設定\n    let _points = this.state.points; \n    _points[index].bool = {\n      dot : _dotProduct<0?false:true,\n      cross : _crossProduct<0?true:false,\n    }\n    _points[index].rate = {\n      dot : _dotProduct<0?-rate_vec_point:rate_vec_point,\n      cross : rate_from_edge,\n    }\n    this.setState({\n      points:_points,\n    })\n  }\n\n  //両目を描画\n  drawPoints (){\n    let landmarks = this.props.landmarks;\n    const context = this.canvas.getContext(\"2d\");\n    context.clearRect(0, 0, VIDEO_SIZE.width, VIDEO_SIZE.height);\n    let index = 0;\n    _.each ( this.props.positions ,  point =>{\n      if(index == 38) {\n        setPoint( this.canvas , {x:point.x , y:point.y} , `rgba(255,0,0)`);\n      }\n      if(index == 44) {\n        setPoint( this.canvas , {x:point.x , y:point.y} , `rgba(0,255,0)`);\n      }\n      index++;\n    });\n  }\n\n  //検出したパーツ\n  drawParts () {\n    let landmarks = this.props.landmarks;\n    // パーツごとに色分け\n    const getColor = ( col , index ) =>{\n      let cols = [\n        `rgb(255,${index},${index})`,\n        `rgb(${index},255,${index})`,\n        `rgb(${index},${index},255)`,\n        `rgb(255,255,${index})`,\n        `rgb(${index},255,255)`,\n        `rgb(255,${index},255)`,\n        `rgb(${index},${index},${index})`,\n      ]\n      return cols[col];\n    }\n\n    let col = 0;//パーツインデックス\n    let index = 0;//パーツ内インデックス\n    let step = Math.floor(255/10);//色の段階\n    _.each(landmarks ,( parts , key )=> {\n      col++;\n      index = 0;\n      parts.map ( point => {\n        index++;\n        if(( col==3 || col==4 )&& index == 3) {\n          setPoint( this.canvas , {x:point.x , y:point.y} , getColor(col , index*step ));\n        }\n      })\n    })\n    \n  }\n\n  //追加\n  addPoint (e) {\n    var rect = this.canvas.getBoundingClientRect();\n    // const x = (rect.width/2)+((rect.width/2) - (e.clientX - rect.left));\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    let _points = this.state.points;\n    _points.push({\n      vector:{x:x,y:y},\n      rate:null,\n    });\n    this.setState({\n      points : _points\n    });\n    console.log(\"points \" , _points );\n  }\n\n  render(){\n    return(\n      <canvas\n        ref={ref => {\n          this.setCanvas(ref);\n        }}\n        width={VIDEO_SIZE.width}\n        height={VIDEO_SIZE.height}\n        className = {styles[\"overlayCanvas\"]}\n        onClick = {(e)=>{\n          this.addPoint(e);\n        }}\n      />\n    )\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}