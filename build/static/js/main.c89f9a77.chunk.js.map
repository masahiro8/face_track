{"version":3,"sources":["components/VideoCanvas.scss","canvas.point.js","components/FaceDetect.jsx","config.js","components/VideoCanvas.jsx","util/vector.js","components/AssetLoader.jsx","App.js","canvas.image.js","serviceWorker.js","index.js"],"names":["module","exports","overlayCanvas","videoimage","setPoint","canvas","pos","col","ctx","getContext","fillStyle","fillRect","x","y","FaceDetect","_Component","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","pointlog","net","faceapi","state","faceDetect","inherits","createClass","key","value","_componentDidMount","asyncToGenerator","regenerator_default","a","mark","_callee2","_this2","wrap","_context2","prev","next","tinyFaceDetector","load","console","log","setInterval","_callee","_context","predict","stop","interval","apply","arguments","_predict","_callee3","options","result","_context3","abrupt","inputSize","scoreThreshold","video","withFaceLandmarks","sent","setState","react_default","createElement","Component","VIDEO_SIZE","width","height","INTERVAL","Math","floor","PARTS_INDEX","Video","media","selfRef","initCam","navigator","mediaDevices","getUserMedia","audio","facingMode","size","p","Promise","resolve","then","stream","srcObject","onloadedmetadata","e","catch","err","alert","_this3","ref","setSelf","className","autoPlay","playsInline","Canvas","_this4","_this5","draw","getBoundingClientRect","context","drawImage","_this6","set","id","VideoImage","_Component3","_this7","_this8","styles","VideoCanvas_Video","setVideo","VideoCanvas_Canvas","setCanvas","shiftBase","b","toFixed","vectorLength","v","sqrt","dotProduct","crossProduct","distance","p1","p2","pow","AssetLoader","done","progress","images","_","assets","asset","loadImage","img","Image","onload","image","push","type","length","setImages","src","children","Fragment","show","BASE_PARTS","VECTOR_PARTS","src_App","App","overlay","landmarks","positions","initCanvas","VideoCanvas_VideoImage","FaceDetect_FaceDetect","_faceapi$getMediaDime","resizedResults","map","res","forSize","jawOutline","getJawOutline","nose","getNose","mouth","getMouth","leftEye","getLeftEye","rightEye","getRightEye","leftEyeBrow","getLeftEyeBrow","rightEyeBrow","getRightEyeBrow","getLandmarks","faceLandmarks","AssetLoader_AssetLoader","App_FaceDetectView","showEyes","showPoints","setRef","setOverlay","FaceDetectView","tilt","points","nextProps","clearCanvas","detectTilt","drawPoints","drawParts","point","index","initPointRate","begin","end","_end","vector","_crossProduct","radian","acos","deg","PI","myPoint","_begin","_end_vec","vec_length","point_distance","rate","dot","vec","distanceFromCenter","cross","bool","vec2","cos","sin","_x","_y","rot","save","_rot","cx","cy","setTransform","restore","setRotate","_myPoint","distanceFromEdge","abs","_dotProduct","cos_theta","_a","_b","dotDistance","math","rate_vec_point","rate_from_edge","_points","clearRect","step","parts","concat","getColor","rect","clientX","left","clientY","top","onClick","addPoint","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c89f9a77.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"overlayCanvas\":\"_1VTjcrIdjUewwZ-qVkXQxP\",\"videoimage\":\"_27P8rrrUDhjUTuQVCNHvHs\"};","import * as faceapi from \"face-api.js/dist/face-api.js\";\r\n\r\nexport const setPoint = ( canvas , pos  , col) =>{\r\n  const ctx = canvas.getContext(\"2d\");\r\n  ctx.fillStyle = col||\"#0ff\";\r\n  ctx.fillRect(pos.x,pos.y,4,4);\r\n}\r\n\r\nexport const getLandmarks = (landmarks) => {\r\n  const jawOutline = landmarks.getJawOutline();\r\n  const nose = landmarks.getNose();\r\n  const mouth = landmarks.getMouth();\r\n  const leftEye = landmarks.getLeftEye();\r\n  const rightEye = landmarks.getRightEye();\r\n  const leftEyeBrow = landmarks.getLeftEyeBrow();\r\n  const rightEyeBrow = landmarks.getRightEyeBrow();\r\n  return {\r\n    nose:nose,\r\n    mouth:mouth,\r\n    leftEye:leftEye,\r\n    rightEye:rightEye,\r\n    leftEyeBrow:leftEyeBrow,\r\n    rightEyeBrow:rightEyeBrow,\r\n    jawOutline:jawOutline,\r\n  }\r\n}\r\n\r\nexport const resizeCanvasAndResults = (dimensions, canvas, results) => {\r\n  const { width, height } = dimensions instanceof HTMLVideoElement\r\n    ? faceapi.getMediaDimensions(dimensions)\r\n    : dimensions\r\n  canvas.width = width\r\n  canvas.height = height\r\n\r\n  // resize detections (and landmarks) in case displayed image is smaller than\r\n  // original size\r\n  return results.map(res => res.forSize(width, height))\r\n}\r\n\r\nexport const drawDetections = (dimensions, canvas, detections)=> {\r\n  console.log(\"drawDetections\" ,detections);\r\n  const resizedDetections = resizeCanvasAndResults(dimensions, canvas, detections)\r\n  faceapi.drawDetection(canvas, resizedDetections)\r\n}\r\n\r\nexport const drawLandmarks = (dimensions, canvas, results, withBoxes = true) => {\r\n  \r\n  const resizedResults = resizeCanvasAndResults(dimensions, canvas, results)\r\n  console.log(\"drawLandmarks = \",resizedResults);\r\n  if (withBoxes) {\r\n    faceapi.drawDetection(canvas, resizedResults.map(det => det.detection))\r\n  }\r\n\r\n  const faceLandmarks = resizedResults.map(det => det.landmarks)\r\n  const drawLandmarksOptions = {\r\n    lineWidth: 2,\r\n    drawLines: true,\r\n    color: 'green'\r\n  }\r\n  faceapi.drawLandmarks(canvas, faceLandmarks, drawLandmarksOptions)\r\n}","import React, { Component } from \"react\";\nimport * as _ from \"lodash\";\nimport * as faceapi from \"face-api.js/dist/face-api.js\";\nimport { constant } from \"@tensorflow/tfjs-layers/dist/exports_initializers\";\nimport {setPoint,getLandmarks } from '../canvas.point';\n\n// tiny_face_detector options\nlet inputSize = 128\nlet scoreThreshold = 0.5\n\nexport class FaceDetect extends Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n    this.pointlog = null;\n    this.net = new faceapi.FaceLandmark68TinyNet();\n    this.state = {\n      faceDetect: {},\n    };\n  }\n\n  async componentDidMount() {\n\n    //必要なモデルのロード\n    await faceapi.nets.tinyFaceDetector.load('models/face/');\n    await faceapi.loadFaceLandmarkModel('models/face/');\n    console.log(\"load models\");\n    setInterval(async () => {\n      await this.predict();\n    }, this.props.interval);\n  }\n\n  async predict() {\n    if (!this.props.canvas) return;\n    //検出\n    let inputSize = 128;\n    let scoreThreshold = 0.5;\n    const options = new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold })\n    const result = await faceapi.detectSingleFace(this.props.video, options).withFaceLandmarks();\n    //console.log(\"predict result\" ,result);\n    if (result) {\n      //console.log(\"result \" , result );\n      // const { width, height } = faceapi.getMediaDimensions(this.props.video);\n      // const resizedResults = [result].map(res => res.forSize(width, height));\n      this.setState({ faceDetect: result });\n      this.props.result(result);\n    }\n  }\n\n  render() {\n    return (\n      <div/>\n    );\n  }\n}","export const location = 'https://192.168.100.109:3000/';\n\nexport const VIDEO_SIZE = {\n  width:640,\n  height:480,\n}\nexport const INTERVAL =  Math.floor(1000/30);\n\n//追従するパーツ\nexport const PARTS_INDEX = {\n  nose :30,\n  leftEye :38,\n  rightEye :44,\n} //[30,38,44]; // 鼻 左目　右目","import React, { Component } from \"react\";\nimport styles from './VideoCanvas.scss';\nimport {VIDEO_SIZE} from '../config';\n\nclass Video extends Component {\n  constructor(props) {\n    super(props);\n    this.media = null;\n    this.selfRef = null;\n  }\n\n  async componentDidMount() {\n    await this.initCam();\n    console.log(\"detect init\");\n  }\n\n  async initCam() {\n\n    // const stream = await navigator.mediaDevices.getUserMedia({ video: {} }) \n    this.media = navigator.mediaDevices.getUserMedia({\n      audio: false,\n      video: {\n        facingMode: \"environment\",\n        width: this.props.size.width, \n        // height: this.props.size.height,\n      },\n    });\n\n    let p = new Promise( resolve =>{\n      this.media.then(stream => {\n        this.selfRef.srcObject = stream;\n        this.selfRef.onloadedmetadata = function(e) {\n          console.log(\"Onload video\" , e);\n          resolve();\n        };\n      });\n      \n      this.media.catch(err => {\n        alert(err);\n      });\n    });\n\n    return p;\n    \n  }\n\n  render() {\n    return (\n      <video\n        ref={ref => {\n          this.selfRef = ref;\n          this.props.setSelf(ref);\n        }}\n        className=\"video\"\n        autoPlay\n        playsInline\n        width={VIDEO_SIZE.width}\n        height={VIDEO_SIZE.height}\n      />\n    );\n  }\n}\n\nclass Canvas extends Component {\n  constructor(props) {\n    super(props);\n    this.canvas = null;\n  }\n\n  componentDidMount() {\n    setInterval(() => {\n      this.draw();\n    }, this.props.interval);\n  }\n\n  draw() {\n    if (!this.props.video || !this.props.canvas) {\n      return;\n    }\n    let rect = this.props.video.getBoundingClientRect();\n    var context = this.canvas.getContext(\"2d\");\n    this.canvas.width = this.props.size.width;\n    this.canvas.height = this.props.size.height;\n    context.drawImage(\n      this.props.video,0, 0,\n      this.props.size.width,\n      this.props.size.height);\n  }\n\n  render() {\n    return (\n      <canvas\n        ref={ref => {\n          this.canvas = ref;\n          this.props.set(ref);\n        }}\n        id={\"canvas\"}\n        className=\"canvas\"\n      />\n    );\n  }\n}\n\nexport class VideoImage extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      video: null,\n      canvas: null,\n    };\n  }\n\n  setVideo(ref) {\n    if (this.state.video !== ref && ref) {\n      this.setState({ video: ref });\n      this.props.video(ref);\n    }\n  }\n\n  setCanvas(ref) {\n    if (this.state.canvas !== ref && ref) {\n      this.setState({ canvas: ref });\n      this.props.canvas(ref);\n    }\n  }\n\n  render(){\n    return(\n      <div className={styles[\"videoimage\"]}>\n        <Video\n          size = {this.props.size}\n          setSelf={ref => {\n            this.setVideo(ref);\n          }}\n        />\n        <Canvas\n          size = {this.props.size}\n          video={this.state.video}\n          set={ref => {\n            this.setCanvas(ref);\n          }}\n          interval={this.props.interval}\n        />\n      </div>\n    )\n  }\n}","    //原点補正\n    export const shiftBase = ( b ,p ) =>{\n      return {x:(p.x-b.x).toFixed(2),y:(p.y-b.y).toFixed(2)};\n    }\n    //ベクトル長さ\n    export const vectorLength =(v)=>{\n      return Math.sqrt( v.x * v.x + v.y * v.y);\n      //return Math.pow( ( v.x * v.x ) + ( v.y * v.y ), 0.5 );\n    }\n    //内積:正しい\n    export const dotProduct = (a,b) =>{\n      return a.x * b.x + a.y * b.y;\n    }\n\n    //外積\n    export const crossProduct = ( p , v ) =>{\n      return p.x * v.y - v.x * p.y;\n    }\n\n    //ベクトルのなす角(ラジアン)\n    //http://www.sousakuba.com/Programming/gs_two_vector_angle.html\n    //https://qiita.com/vkgtaro/items/b2cd00f376c427cb9ea6\n    export const theta = ( a, b ) => {\n      const _a = vectorLength(a);\n      const _b = vectorLength(b);\n      return Math.cos(dotProduct(a,b) / ( _a * _b ));\n    }\n\n    //ベクトル座標 座標,ベクトル\n    export const vecPos = (p,v) => {\n      return {x:p.x/v,y:p.y*v};\n    }\n    //２点間の距離:正しい\n    export const distance = (p1, p2) => {\n      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    };\n\n    //原点(0,0)からx軸の傾き\n    export const tilt = ( a ) => {\n      return a.x / vectorLength(a);\n    }","import React, { Component } from \"react\";\nimport * as _ from 'lodash';\nimport { sigmoid } from \"face-api.js\";\n\nexport default class AssetLoader extends Component {\n  constructor(props){\n    super(props);\n    this.state = {\n      done:false,\n      progress : 0,\n      images : [],\n    }\n    _.map( props.assets , asset =>{\n      this.loadImage(asset);\n    })\n  }\n\n  loadImage( asset ){\n    let img = new Image();\n    img.onload = ( image ) =>{\n      let images = this.state.images\n      images.push({\n        id:asset.id,\n        image:img,\n        type:'image',\n      });\n      this.setState({\n        progress : this.state.progress+1,\n        images:images,\n      })\n      if( this.props.assets.length == this.state.progress ) {\n        this.props.setImages(this.state.images);\n        this.setState({done:true});\n      }\n    }\n    img.src = asset.src;\n  }\n\n  show () {\n    if ( this.state.done )  return <div>{this.props.children}</div> \n    return null\n  }\n\n  render(){\n    return(<React.Fragment>{this.show()}</React.Fragment>)\n  }\n}","import React, { Component } from \"react\";\nimport * as faceapi from \"face-api.js/dist/face-api.js\";\nimport * as _ from 'lodash';\nimport math from 'mathjs';\nimport {FaceDetect} from './components/FaceDetect';\nimport {VideoImage} from './components/VideoCanvas';\nimport {setPoint,getLandmarks } from './canvas.point';\nimport {setImage ,setRotate } from './canvas.image';\nimport styles from './components/VideoCanvas.scss';\nimport { VIDEO_SIZE , INTERVAL ,PARTS_INDEX } from './config';\nimport * as vector from './util/vector';\nimport AssetLoader from './components/AssetLoader';\n\nconst BASE_PARTS = PARTS_INDEX.leftEye;\nconst VECTOR_PARTS = PARTS_INDEX.rightEye;\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.assets =  [\n      {id:1,src:'/images/glasses_01.png',type:'image'},\n    ];\n\n    this.state = {\n      video:null,\n      canvas: null,\n      overlay: null,\n      result : null,\n      landmarks : null,\n      positions : null,\n      assets : [],\n    };\n    this.overlay = null;\n    \n  }\n\n  setCanvas(ref) {\n    if (this.state.canvas !== ref && ref) {\n      this.setState({ canvas: ref });\n    }\n  }\n\n  setVideo(ref) {\n    if (this.state.video !== ref && ref) {\n      this.setState({ video: ref });\n      console.log(\"setVideo \" );\n    }\n  }\n\n  setOverlay(ref) {\n    if (this.state.overlay !== ref && ref) {\n      this.setState({ overlay: ref });\n      this.initCanvas();\n      console.log(\"setOverlay \" );\n    }\n  }\n\n  initCanvas(){\n    if( !this.state.canvas || !this.state.overlay ) return;\n    this.setState({\n      width:VIDEO_SIZE.width,\n      height:VIDEO_SIZE.height\n    });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <VideoImage \n          size = {VIDEO_SIZE}\n          interval={INTERVAL}\n          video ={(ref)=>{ this.setVideo(ref); }}\n          canvas = {(ref)=>{ this.setCanvas(ref); }}\n        />\n        <FaceDetect \n          canvas={this.state.canvas} \n          video={this.state.video}\n          interval={INTERVAL}\n          result={(result)=>{\n            const { width, height } = faceapi.getMediaDimensions(this.state.video);\n            const resizedResults = [result].map(res => res.forSize(width, height));\n            const landmarks = getLandmarks(resizedResults[0].faceLandmarks);\n\n            this.setState({\n              landmarks:landmarks,\n              positions:resizedResults[0].landmarks.positions\n            });\n          }} />\n        <AssetLoader\n          assets = {this.assets}\n          setImages = {(images)=>{\n            this.setState({assets:images});\n          }}\n        >\n          <FaceDetectView\n            video = {this.state.video}\n            landmarks ={this.state.landmarks}\n            positions = {this.state.positions}\n            showEyes = {true}\n            showPoints = {false}\n            setRef = {(ref)=>{this.setOverlay(ref)}}\n            assets = {this.state.assets}\n          />\n        </AssetLoader>\n      </div>\n    );\n  }\n}\nexport default App;\n\nclass FaceDetectView extends Component {\n  constructor(props){\n    super(props);\n    this.canvas = null;\n    this.tilt = null;\n\n    this.state ={\n      points:[],\n      tilt:null,\n    };\n  }\n\n  componentWillReceiveProps(nextProps){\n    if(nextProps.landmarks) {\n      this.clearCanvas();\n\n      //傾き\n      this.detectTilt(nextProps.positions[VECTOR_PARTS],nextProps.positions[BASE_PARTS]);\n\n      if(this.props.showEyes) this.drawPoints();\n      if(this.props.showPoints) this.drawParts();\n      if(this.state.points.length) {\n        _.each ( this.state.points ,  ( point , index ) =>{\n          this.initPointRate( point,index ,nextProps.positions[BASE_PARTS] , nextProps.positions[VECTOR_PARTS]);\n          this.setPoint(point,index ,nextProps.positions[BASE_PARTS] , nextProps.positions[VECTOR_PARTS]);\n        })\n      }\n    }\n  }\n\n  setCanvas ( ref ) {\n    this.canvas = ref;\n    this.props.setRef(ref);\n  }\n\n  //傾き検出\n  detectTilt ( begin , end ){\n    //原点をbeginとして補正\n    const _begin = { x:0 , y: 0};\n    const _end = vector.shiftBase( begin , end);\n    //なす角\n    const _crossProduct = vector.crossProduct(_end,{x:100,y:0});\n    const radian = Math.acos(vector.tilt(_end));\n    const deg = radian*(180/Math.PI);\n    this.tilt = _crossProduct<0?radian:-deg*(Math.PI/180);\n  }\n\n  //描画\n  setPoint ( myPoint, index , begin, end ) {\n\n    //原点をbeginとして補正\n    const _begin = { x:0 , y: 0};\n    const _end = vector.shiftBase( begin , end);\n    //ベクトル距離\n    const _end_vec = vector.vectorLength(_end);\n    //begin > end 距離\n    const vec_length = vector.distance(_begin , _end);\n    //線上の距離\n    const point_distance = vec_length*myPoint.rate.dot;\n    const vec = {\n      x : ( _begin.x+_end.x/_end_vec*point_distance ) + begin.x,\n      y : ( _begin.y+_end.y/_end_vec*point_distance ) + begin.y\n    }\n    //半径\n    const distanceFromCenter = vec_length*myPoint.rate.cross;\n    const r = myPoint.bool.cross?270:90;\n    const radian = r*Math.PI/180;\n    const vec2 = {\n      x:distanceFromCenter * Math.cos(radian) + vec.x,\n      y:distanceFromCenter * Math.sin(radian) + vec.y,\n    }\n\n    //仮で画像描画\n    if(this.props.assets[0].image ) {\n      const img = this.props.assets[0].image;\n      let _x = vec2.x - (img.width/2);\n      let _y = vec2.y - (img.height/2);\n      // setImage( this.canvas ,{x:_x , y:_y} , img );\n      setRotate( this.canvas ,{x:_x , y:_y}, this.tilt , img );\n    }\n    setPoint( this.canvas , {x:vec2.x , y:vec2.y} , `rgba(255,255,255)`);\n  }\n\n  //初期値\n  initPointRate( myPoint, index , begin, end ) {\n\n    if ( myPoint.rate ) return;\n\n    //原点をbeginとして補正\n    const _begin = { x:0 , y: 0};\n    const _end = vector.shiftBase( begin , end);\n    const _myPoint = vector.shiftBase( begin ,myPoint.vector);\n    \n    //外積\n    const _crossProduct = vector.crossProduct(_end,_myPoint);\n    const distanceFromEdge = Math.abs(_crossProduct/vector.distance(_begin , _end));//頂点から|begin|endへの距離\n\n    //内積\n    const _dotProduct = vector.dotProduct(_end,_myPoint);// _dotProduct<0 -> 正\n    const cos_theta = vector.theta(_end,_myPoint);\n    const _theta = math.acos(cos_theta);//θ\n    const dotDistance = _theta*vector.vectorLength(_myPoint);//内積 -> 絶対値なので正負の判定を入れる必要がある\n\n    //割合\n    const vec_length = vector.distance(_begin , _end);\n    const rate_vec_point = dotDistance/vec_length;//正しい\n    const rate_from_edge = distanceFromEdge/vec_length;\n    \n    // console.log(\"cos_theta \",\n    //   vector.vectorLength(_end),\n    //   vector.vectorLength(_myPoint) , \n    //   cos_theta ,\n    //   _theta*180.0/Math.PI,\n    //   vector.dotProduct(_end,_myPoint),\n    // );\n\n    //初期値を設定\n    let _points = this.state.points; \n    _points[index].bool = {\n      dot : _dotProduct<0?false:true,\n      cross : _crossProduct<0?true:false,\n    }\n    _points[index].rate = {\n      dot : _dotProduct<0?-rate_vec_point:rate_vec_point,\n      cross : rate_from_edge,\n    }\n    this.setState({\n      points:_points,\n    })\n  }\n\n  //キャンバスをクリア\n  clearCanvas () {\n    const context = this.canvas.getContext(\"2d\");\n    context.clearRect(0, 0, VIDEO_SIZE.width, VIDEO_SIZE.height);\n  }\n\n  //ベースパーツを描画\n  drawPoints (){\n    let index = 0;\n    _.each ( this.props.positions ,  point =>{\n      if(index == BASE_PARTS) {\n        setPoint( this.canvas , {x:point.x , y:point.y} , `rgba(255,0,0)`);\n      }\n      if(index == VECTOR_PARTS) {\n        setPoint( this.canvas , {x:point.x , y:point.y} , `rgba(0,255,0)`);\n      }\n      index++;\n    });\n  }\n\n  //検出したパーツ\n  drawParts () {\n    let landmarks = this.props.landmarks;\n    // パーツごとに色分け\n    const getColor = ( col , index ) =>{\n      let cols = [\n        `rgb(255,${index},${index})`,\n        `rgb(${index},255,${index})`,\n        `rgb(${index},${index},255)`,\n        `rgb(255,255,${index})`,//左目\n        `rgb(${index},255,255)`,//右目\n        `rgb(255,${index},255)`,\n        `rgb(${index},${index},${index})`,\n      ]\n      return cols[col];\n    }\n\n    let col = 0;//パーツインデックス\n    let index = 0;//パーツ内インデックス\n    let step = Math.floor(255/10);//色の段階\n    _.each(landmarks ,( parts , key )=> {\n      col++;\n      index = 0;\n      parts.map ( point => {\n        index++;\n        setPoint( this.canvas , {x:point.x , y:point.y} , getColor(col , index*step ));\n      })\n    })\n    \n  }\n\n  //追加\n  addPoint (e) {\n    var rect = this.canvas.getBoundingClientRect();\n    // const x = (rect.width/2)+((rect.width/2) - (e.clientX - rect.left));\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n\n    let _points = this.state.points;\n    _points.push({\n      vector:{x:x,y:y},\n      rate:null,\n    });\n    this.setState({\n      points : _points\n    });\n    console.log(\"points \" , _points );\n  }\n\n  render(){\n    return(\n      <canvas\n        ref={ref => {\n          this.setCanvas(ref);\n        }}\n        width={VIDEO_SIZE.width}\n        height={VIDEO_SIZE.height}\n        className = {styles[\"overlayCanvas\"]}\n        onClick = {(e)=>{\n          this.addPoint(e);\n        }}\n      />\n    )\n  }\n}\n","export const setImage = ( canvas ,  pos , img ) => {\n  const ctx = canvas.getContext(\"2d\");\n  ctx.drawImage(img, pos.x, pos.y);\n}\nexport const setRotate = ( canvas , pos , rot , img ) => {\n  const ctx = canvas.getContext(\"2d\");\n  ctx.save();\n  const _rot = rot;\n  // 回転の中心位置を計算（画像の中心を回転中心にする）\n  const cx = pos.x + img.width/2;\n  const cy = pos.y + img.height/2;\n  // 画像を回転\n  ctx.setTransform(\n    Math.cos(_rot), \n    Math.sin(_rot), \n    -Math.sin(_rot), \n    Math.cos(_rot),\n    cx-cx*Math.cos(_rot)+cy*Math.sin(_rot),\n    cy-cx*Math.sin(_rot)-cy*Math.cos(_rot)\n  );\n  ctx.drawImage(img, pos.x, pos.y);\n  ctx.restore();\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}